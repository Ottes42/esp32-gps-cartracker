esphome:
  name: gps-cartracker
  friendly_name: GPS Cartracker
  name_add_mac_suffix: true
  min_version: 2025.8.0  # Docker version compatibility
  platformio_options:
    board_build.f_flash: 40000000L
    board_build.flash_mode: dio
    board_build.flash_size: 4MB
  libraries:
    - "TinyGPSPlus"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          // SD card will be initialized by sd_mmc_card component
          id(sd_initialized) = true;
          ESP_LOGI("setup", "GPS CarTracker initialized with SD card support");
          
          // Authorization: Basic base64(user:pass)
          std::string creds = std::string("${BASIC_AUTH_USER}") + ":" + std::string("${BASIC_AUTH_PASS}");
          auto b64 = [](const std::string &in)->std::string {
            static const char tbl[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            std::string out; out.reserve(((in.size()+2)/3)*4);
            size_t i=0; 
            while (i+3<=in.size()) {
              uint32_t n = ((uint8_t)in[i]<<16)|((uint8_t)in[i+1]<<8)|((uint8_t)in[i+2]);
              out.push_back(tbl[(n>>18)&63]);
              out.push_back(tbl[(n>>12)&63]);
              out.push_back(tbl[(n>>6)&63]);
              out.push_back(tbl[n&63]);
              i+=3;
            }
            if (i+1==in.size()) {
              uint32_t n = ((uint8_t)in[i]<<16);
              out.push_back(tbl[(n>>18)&63]); out.push_back(tbl[(n>>12)&63]); out.push_back('='); out.push_back('=');
            } else if (i+2==in.size()) {
              uint32_t n = ((uint8_t)in[i]<<16)|((uint8_t)in[i+1]<<8);
              out.push_back(tbl[(n>>18)&63]); out.push_back(tbl[(n>>12)&63]); out.push_back(tbl[(n>>6)&63]); out.push_back('=');
            }
            return out;
          };
          id(auth_b64) = b64(creds);
      # If ACC is off at boot: single temp ping then sleep
      - if:
          condition:
            binary_sensor.is_off: acc_present
          then:
            - script.execute: temp_ping_once
            - delay: 2s
            - deep_sleep.enter: ds1

# Use external SD/MMC component for ESP32
external_components:
  - source: github://n-serrette/esphome_sd_card@main
    components: [sd_mmc_card]

sd_mmc_card:
  clk_pin: GPIO14   # CLK - Safe pin
  cmd_pin: GPIO27   # CMD - Safe pin (changed from GPIO15)
  data0_pin: GPIO26 # D0 - Safe pin (changed from GPIO2)
  data1_pin: GPIO25 # D1 - Safe pin (changed from GPIO4)  
  data2_pin: GPIO33 # D2 - Safe pin (changed from GPIO12)
  data3_pin: GPIO32 # D3 - Safe pin (changed from GPIO13)
  mode_1bit: false  # Use 4-bit mode for better performance

esp32:
  board: esp32dev  # Generic ESP32 board
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_FATFS_LFN_STACK: "y"

substitutions:
  WIFI_SSID_1: !secret wifi_ssid
  WIFI_PASS_1: !secret wifi_password
  STATIC_IP_1: "192.168.1.25"
  STATIC_GW_1: "192.168.1.1"
  STATIC_MASK_1: "255.255.255.0"  

  # Upload target URL and Basic Auth Credentials
  UPLOAD_TARGET: "https://gps.example.com/upload/"
  BASIC_AUTH_USER: "gps-catracker"
  BASIC_AUTH_PASS: "CHANGEME_SECRET"

  # ESP32 GPIO pins - Using safe, non-strapping pins
  PIN_UART_RX:   GPIO16  # Safe pin
  PIN_UART_TX:   GPIO17  # Safe pin
  PIN_DHT:       GPIO21  # Safe pin (changed from GPIO5)
  DHT_MODEL:     "DHT11"
  PIN_ACC_SENSE: GPIO18  # Safe pin
  PIN_LED:       GPIO19  # Safe pin (changed from GPIO2)

wifi:
  networks:
    - ssid: ${WIFI_SSID_1}
      password: ${WIFI_PASS_1}
      manual_ip:
        static_ip: ${STATIC_IP_1}
        gateway: ${STATIC_GW_1}
        subnet: ${STATIC_MASK_1}
    # - ssid: ${WIFI_SSID_2}
    #   password: ${WIFI_PASS_2}
    #   manual_ip:
    #     static_ip: ${STATIC_IP_2}
    #     gateway: ${STATIC_GW_2}
    #     subnet: ${STATIC_MASK_2}

  ap:
    ssid: "gps-cartracker-setup"
    password: "setup-setup"

  on_connect:
    then:
      - script.execute: sync_logs

logger:
  level: INFO
  logs:
    component: WARN

ota:
  - platform: esphome  # set password locally if needed

uart:
  id: gps_uart
  rx_pin: ${PIN_UART_RX}
  tx_pin: ${PIN_UART_TX}
  baud_rate: 9600

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin

sensor:
  - platform: template
    id: speed_kmh
    unit_of_measurement: "km/h"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
      if (isnan(id(gps_speed_mps))) return NAN;
      return id(gps_speed_mps) * 3.6;

  - platform: dht
    pin: ${PIN_DHT}
    model: ${DHT_MODEL}
    temperature:
      id: car_temp_c
    humidity:
      id: car_hum_pct
    update_interval: 15s

binary_sensor:
  - platform: gpio
    id: acc_present
    pin:
      number: ${PIN_ACC_SENSE}
      mode:
        input: true
        pullup: false
        pulldown: true
    filters:
      - delayed_on: 50ms
      - delayed_off: 500ms
    on_press:
      then:
        - deep_sleep.prevent: ds1
        - script.stop: shutdown_sequence
    on_release:
      then:
        - script.execute: shutdown_sequence

# Manual SD card implementation with ESP-IDF

globals:
  - id: sd_initialized
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: auth_b64
    type: std::string
    restore_value: no
    initial_value: ""
  - id: gps_lat
    type: double
    restore_value: no
    initial_value: '0.0'
  - id: gps_lon
    type: double
    restore_value: no
    initial_value: '0.0'
  - id: gps_alt
    type: double
    restore_value: no
    initial_value: '0.0'
  - id: gps_speed_mps
    type: double
    restore_value: no
    initial_value: '0.0'
  - id: gps_sat
    type: int
    restore_value: no
    initial_value: '0'
  - id: gps_course
    type: double
    restore_value: no
    initial_value: '0.0'
  - id: gps_valid
    type: bool
    restore_value: no
    initial_value: 'false'

text_sensor:
  - platform: template
    id: logfile
    lambda: |-
      auto t = id(sntp_time).now();
      if (!t.is_valid()) return std::string("current.csv");
      char buf[40];
      snprintf(buf, sizeof(buf), "%04d-%02d-%02d_%02d.csv",
               t.year, t.month, t.day_of_month, t.hour);
      return std::string(buf);

light:
  - platform: status_led
    pin: ${PIN_LED}  # Now GPIO19 instead of GPIO2
    id: device_led

http_request:
  id: http_cli
  useragent: esphome-cartracker/${BASIC_AUTH_USER}
  timeout: 30s
  verify_ssl: false

interval:
  # GPS data reading with TinyGPSPlus
  - interval: 1s
    then:
      - lambda: |-
          #include <TinyGPS++.h>
          static TinyGPSPlus gps;
          
          // Read available GPS data from UART
          while (id(gps_uart).available()) {
            char c = id(gps_uart).read();
            if (gps.encode(c)) {
              // GPS sentence complete, update values
              if (gps.location.isValid()) {
                id(gps_lat) = gps.location.lat();
                id(gps_lon) = gps.location.lng();
                id(gps_valid) = true;
              }
              if (gps.altitude.isValid()) {
                id(gps_alt) = gps.altitude.meters();
              }
              if (gps.speed.isValid()) {
                id(gps_speed_mps) = gps.speed.mps();
              }
              if (gps.satellites.isValid()) {
                id(gps_sat) = gps.satellites.value();
              }
              if (gps.course.isValid()) {
                id(gps_course) = gps.course.deg();
              }
            }
          }
  # 2s driving log when ACC on
  - interval: 2s
    then:
      - if:
          condition:
            binary_sensor.is_on: acc_present
          then:
            - lambda: |-
                auto t = id(sntp_time).now();
                char ts[32];
                if (t.is_valid()) {
                  snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                           t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
                } else {
                  snprintf(ts, sizeof(ts), "no_time");
                }
                char line[240];
                snprintf(line, sizeof(line),
                  "%s,%.6f,%.6f,%.1f,%.1f,%.0f,%.0f,%.0f,%.1f,%.1f\n",
                  ts,
                  (double) id(gps_lat),
                  (double) id(gps_lon),
                  (double) id(gps_alt),
                  (double) id(speed_kmh).state,
                  (double) id(gps_sat),
                  (double) id(gps_course),
                  0.0,  // hdop placeholder
                  (double) id(car_temp_c).state,
                  (double) id(car_hum_pct).state
                );
                std::string log_line(line);
                ESP_LOGD("gps", "Log data: %s", line);
            - sd_mmc_card.append_file:
                path: !lambda "return \"/\" + id(logfile).state.c_str();"
                data: !lambda |
                  auto t = id(sntp_time).now();
                  char ts[32];
                  if (t.is_valid()) {
                    snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                             t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
                  } else {
                    snprintf(ts, sizeof(ts), "no_time");
                  }
                  char line[240];
                  snprintf(line, sizeof(line),
                    "%s,%.6f,%.6f,%.1f,%.1f,%.0f,%.0f,%.0f,%.1f,%.1f\n",
                    ts,
                    (double) id(gps_lat),
                    (double) id(gps_lon),
                    (double) id(gps_alt),
                    (double) id(speed_kmh).state,
                    (double) id(gps_sat),
                    (double) id(gps_course),
                    0.0,  // hdop placeholder
                    (double) id(car_temp_c).state,
                    (double) id(car_hum_pct).state
                  );
                  std::string str(line);
                  return std::vector<uint8_t>(str.begin(), str.end());

script:
  - id: sync_logs
    mode: queued
    then:
      - http_request.post:
          url: !lambda 'return (std::string("${UPLOAD_TARGET}") + id(logfile).state.c_str()).c_str();'
          request_headers:
            Authorization: !lambda 'return (std::string("Basic ") + id(auth_b64)).c_str();'
            Content-Type: text/csv
          body: !lambda |-
            // Read log data from SD card file
            // Note: For now returning empty string as direct file read API needs implementation
            // TODO: Implement file reading from SD card
            std::string body2 = "";
            return body2;
      - sd_mmc_card.delete_file:
          path: !lambda "return \"/\" + id(logfile).state.c_str();"

  - id: shutdown_sequence
    mode: restart
    then:
      - delay: 60s
      - if:
          condition:
            binary_sensor.is_off: acc_present
          then:
            - script.execute: sync_logs
            - delay: 3s
            - deep_sleep.enter: ds1

  - id: temp_ping_once
    then:
      - sd_mmc_card.append_file:
          path: !lambda "return \"/\" + id(logfile).state.c_str();"
          data: !lambda |
            auto t = id(sntp_time).now();
            char ts[32];
            if (t.is_valid()) {
              snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                       t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
            } else {
              snprintf(ts, sizeof(ts), "no_time");
            }
            char line[200];
            snprintf(line, sizeof(line),
              "%s,%s,%s,%.1f,%.1f,%s,%s,%s,%.1f,%.1f\n",
              ts, "nan", "nan", 0.0, 0.0, "nan", "nan", "nan",
              (double) id(car_temp_c).state,
              (double) id(car_hum_pct).state
            );
            std::string str(line);
            ESP_LOGD("temp", "Temp ping data: %s", line);
            return std::vector<uint8_t>(str.begin(), str.end());

deep_sleep:
  id: ds1
  sleep_duration: 30min