substitutions:
  # WiFi Configuration
  WIFI_SSID_1: !secret wifi_ssid
  WIFI_PASS_1: !secret wifi_password
  STATIC_IP_1: "192.168.1.25"
  STATIC_GW_1: "192.168.1.1"
  STATIC_MASK_1: "255.255.255.0"
  
  # GPIO Pin Assignments for BerryBase NodeMCU-ESP32 (standard ESP32)
  PIN_UART_RX: "GPIO16"
  PIN_UART_TX: "GPIO17" 
  PIN_DHT: "GPIO21"     # Safe pin, away from SD card
  DHT_MODEL: "DHT11"
  PIN_ACC_SENSE: "GPIO18" # Safe pin, away from SD card
  PIN_LED: "GPIO19"     # Safe pin, away from SD card
  
  # Upload Configuration
  UPLOAD_TARGET: "https://gps.example.com/upload/"
  BASIC_AUTH_USER: "gps-cartracker"
  BASIC_AUTH_PASS: "CHANGEME_SECRET"

esphome:
  name: gps-cartracker
  friendly_name: GPS Cartracker
  min_version: 2025.8.0
  on_shutdown:
    then:
      - script.execute: sync_logs

esp32:
  # Board updated to BerryBase NodeMCU-ESP32 (standard ESP32, not ESP32-C3)
  board: nodemcu-32s
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_FATFS_LFN_STACK: "y"

# Use the external SD card custom component
external_components:
  - source: github://n-serrette/esphome_sd_card@main
    components: [ sd_mmc_card ]

# SD card custom component configuration - Standard ESP32 SDMMC pins
# Note: GPIO15, GPIO2, GPIO12 are strapping pins but are standard for SD card interface
sd_mmc_card:
  id: sd_card
  clk_pin: GPIO14
  cmd_pin: GPIO15  # Strapping pin - accepted for SD card functionality
  data0_pin: GPIO2  # Strapping pin - accepted for SD card functionality  
  data1_pin: GPIO4
  data2_pin: GPIO12  # Strapping pin - accepted for SD card functionality
  data3_pin: GPIO13
# Top-level intervals
interval:
  # 2s driving log when ACC is on
  - interval: 2s
    then:
      - if:
          condition:
            binary_sensor.is_on: acc_present
          then:
            - logger.log:
                format: "GPS_DATA: %s,%.6f,%.6f,%.1f,%.1f,%.0f,%.0f,%.0f,%.1f,%.1f"
                args:
                  - !lambda |
                      auto t = id(sntp_time).now();
                      static char ts[32];
                      if (t.is_valid()) {
                        snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                                 t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
                      } else {
                        snprintf(ts, sizeof(ts), "no_time");
                      }
                      return std::string(ts);
                  - id(gps_latitude).state
                  - id(gps_longitude).state
                  - id(gps_altitude).state
                  - id(speed_kmh).state
                  - id(gps_satellites).state
                  - id(gps_course).state
                  - 0.0f
                  - id(car_temp_c).state
                  - id(car_hum_pct).state
            # Build a CSV line and append to RAM buffer
            - lambda: |-
                auto t = id(sntp_time).now();
                char ts[32];
                if (t.is_valid()) {
                  snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                           t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
                } else {
                  snprintf(ts, sizeof(ts), "no_time");
                }
                char line[192];
                snprintf(line, sizeof(line), "%s,%.6f,%.6f,%.1f,%.1f,%.0f,%.0f,%.0f,%.1f,%.1f\\n",
                  ts,
                  id(gps_latitude).state,
                  id(gps_longitude).state,
                  id(gps_altitude).state,
                  id(speed_kmh).state,
                  id(gps_satellites).state,
                  id(gps_course).state,
                  0.0f,
                  id(car_temp_c).state,
                  id(car_hum_pct).state);
                id(csv_cache_ram) += std::string(line);

  # Jede Minute: RAM-Buffer auf SD-Karte anhängen und leeren
  - interval: 60s
    then:
      - lambda: |-
          std::string str = id(csv_cache_ram);
          if (str.size() == 0) return;
          id(csv_cache_ram).clear();
          // Use C file APIs to append to the SD card file (mount point provided by sd_mmc)
          FILE* f = fopen("/sdcard/gpslog.csv", "a");
          if (f) {
            fwrite(str.c_str(), 1, str.length(), f);
            fclose(f);
          }
      - logger.log: "CSV-Cache wurde auf SD-Karte gespeichert."

# --- Networking, logging, and device peripherals ---
wifi:
  networks:
    - ssid: ${WIFI_SSID_1}
      password: ${WIFI_PASS_1}
      manual_ip:
        static_ip: ${STATIC_IP_1}
        gateway: ${STATIC_GW_1}
        subnet: ${STATIC_MASK_1}

  ap:
    ssid: "gps-cartracker-setup"
    password: "setup-setup"

  on_disconnect:
    then:
      - logger.log: "WiFi lost, keeping AP active"

  on_connect:
    then:
      - script.execute: sync_logs

logger:
  level: INFO

ota:
  - platform: esphome
    password: "9e3f7c8d2a1b5f6e4c9d8e7f2a3b4c5d"

uart:
  id: gps_uart
  rx_pin: GPIO16
  tx_pin: GPIO17
  baud_rate: 9600

# GPS component using ESPHome built-in support
gps:
  uart_id: gps_uart
  latitude:
    id: gps_latitude
  longitude:
    id: gps_longitude
  altitude:
    id: gps_altitude
  speed:
    id: gps_speed
  course:
    id: gps_course
  satellites:
    id: gps_satellites

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin

# Placeholder HTTP upload component: implement auth and post details as needed
http_request:
  useragent: "gps-cartracker/1.0"

sensor:
  - platform: template
    id: speed_kmh
    unit_of_measurement: "km/h"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
      if (isnan(id(gps_speed).state)) return NAN;
      return id(gps_speed).state * 3.6;

  - platform: dht
    pin: ${PIN_DHT}
    model: ${DHT_MODEL}
    temperature:
      id: car_temp_c
    humidity:
      id: car_hum_pct
    update_interval: 15s

binary_sensor:
  - platform: gpio
    id: acc_present
    pin:
      number: ${PIN_ACC_SENSE}
      mode:
        input: true
        pullup: false
        pulldown: true
    filters:
      - delayed_on: 50ms
      - delayed_off: 500ms
    on_press:
      then:
        - deep_sleep.prevent: ds1
        - script.stop: shutdown_sequence
    on_release:
      then:
        - script.execute: shutdown_sequence

# Manual SD card implementation with ESP-IDF

globals:
  - id: sd_initialized
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: auth_b64
    type: std::string
    restore_value: no
    initial_value: ""

  # RAM-Buffer für CSV-Cache (anpassbar, z.B. 8kB)
  - id: csv_cache_ram
    type: std::string
    restore_value: no
    initial_value: ""
  # Flash-Buffer für CSV-Cache
  - id: csv_cache_flash
    type: std::string
    restore_value: no
    initial_value: ""
  
  # Upload data buffer
  - id: upload_data
    type: std::string
    restore_value: no
    initial_value: ""


text_sensor:
  - platform: template
    id: logfile
    lambda: |-
      auto t = id(sntp_time).now();
      if (!t.is_valid()) return std::string("current.csv");
      char buf[40];
      snprintf(buf, sizeof(buf), "%04d-%02d-%02d_%02d.csv",
               t.year, t.month, t.day_of_month, t.hour);
      return std::string(buf);

light:
  - platform: status_led
    id: status_light
    pin: ${PIN_LED}  # Now GPIO19 instead of GPIO2

script:
  - id: sync_logs
    mode: queued
    then:
      # Vor Upload: RAM-Buffer auf SD-Karte flushen (use consistent file paths)
      - lambda: |-
          std::string str = id(csv_cache_ram);
          if (str.size() > 0) {
            id(csv_cache_ram).clear();
            // Write to SD using standard file operations (/sdcard/ mount point)
            FILE* f = fopen("/sdcard/gpslog.csv", "a");
            if (f) {
              fwrite(str.c_str(), 1, str.length(), f);
              fclose(f);
            }
          }
      - logger.log: "RAM cache flushed to SD card."
      
      # Upload: CSV von SD-Karte lesen und senden
      - lambda: |-
          FILE* f = fopen("/sdcard/gpslog.csv", "r");
          if (f) {
            fseek(f, 0, SEEK_END);
            long len = ftell(f);
            if (len > 0) {
              fseek(f, 0, SEEK_SET);
              std::string content(len, '\0');
              fread(&content[0], 1, len, f);
              fclose(f);
              id(upload_data) = content;
              ESP_LOGI("sync_logs", "Read %ld bytes from SD card for upload", len);
            } else {
              fclose(f);
              ESP_LOGW("sync_logs", "SD card file is empty, nothing to upload");
              id(upload_data) = "";
            }
          } else {
            ESP_LOGW("sync_logs", "Could not open SD card file for reading");
            id(upload_data) = "";
          }
      - if:
          condition:
            lambda: 'return !id(upload_data).empty();'
          then:
            - http_request.post:
                url: !lambda 'return (std::string("${UPLOAD_TARGET}") + id(logfile).state.c_str()).c_str();'
                request_headers:
                  Authorization: !lambda 'return (std::string("Basic ") + id(auth_b64)).c_str();'
                  Content-Type: text/csv
                body: !lambda 'return id(upload_data);'
            - logger.log: "Upload von SD-Karte durchgeführt."
            # Nach Upload: Datei auf SD-Karte löschen
            - lambda: 'remove("/sdcard/gpslog.csv");'
            - logger.log: "CSV-Datei auf SD-Karte gelöscht."
          else:
            - logger.log: "Kein Upload - keine Daten auf SD-Karte gefunden."

  - id: shutdown_sequence
    mode: restart
    then:
        - delay: 60s
        # Vor Deep Sleep: RAM-Buffer auf SD-Karte flushen
        - lambda: |-
            std::string str = id(csv_cache_ram);
            if (str.size() > 0) {
              id(csv_cache_ram).clear();
              // Write to SD using standard file operations
              FILE* f = fopen("/sdcard/gpslog.csv", "a");
              if (f) {
                fwrite(str.c_str(), 1, str.length(), f);
                fclose(f);
              }
            }
        - if:
            condition:
              binary_sensor.is_off: acc_present
            then:
              - script.execute: sync_logs
              - delay: 3s
              - deep_sleep.enter: ds1

  - id: temp_ping_once
    then:
      - logger.log:
          format: "TEMP_PING: %s,nan,nan,0.0,0.0,nan,nan,nan,%.1f,%.1f"
          args:
            - !lambda |
                auto t = id(sntp_time).now();
                static char ts[32];
                if (t.is_valid()) {
                  snprintf(ts, sizeof(ts), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                           t.year, t.month, t.day_of_month, t.hour, t.minute, t.second);
                } else {
                  snprintf(ts, sizeof(ts), "no_time");
                }
                return ts;
            - id(car_temp_c).state
            - id(car_hum_pct).state

deep_sleep:
  id: ds1
  sleep_duration: 30min